const path = require('path');

// ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎìú (Í∞ÄÏû• Î®ºÏ†Ä)
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const express = require('express');
const http = require('http');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');

// Import our modularized WebSocket components
const { WebSocketProtocolServer } = require('@recursive/websocket-protocol');
const { Logger: { createLogger } } = require('@recursive/shared');
// Î™®ÎìàÌôîÎêú shared config ÏÇ¨Ïö©
const { config: configManager } = require('@recursive/shared');
const config = configManager.get('websocket');
const { MCPServer } = require('@recursive/mcp-protocol');

// Import modularized AI analysis
const { getDefaultInstance: getAIAnalysis } = require('@recursive/ai-analysis');

// Import shared utilities
const { eventBus, config: sharedConfig, utils } = require('@recursive/shared');

// Î°úÍ∑∏ ÏãúÏä§ÌÖúÏùÄ ÏßÅÏ†ë Python ÏÑúÎ≤ÑÎ°ú ÌÜµÏã†

// Import Python server management
const { spawn } = require('child_process');
const fs = require('fs');
const net = require('net');

class RecursiveServer {
  constructor() {
    this.app = express();
    this.server = http.createServer(this.app);
    this.wsServer = null;
    this.mcpServer = null;
    this.logger = null;
    this.aiAnalysis = null;
    this.isShuttingDown = false;
    
    // Î°úÍ∑∏ ÏãúÏä§ÌÖú Í¥ÄÎ†® ÏÜçÏÑ± Ï∂îÍ∞Ä
    this.logSystem = null;
    this.logCollectors = null;
    this.pythonLogServer = null;
    this.pythonServerPort = process.env.PYTHON_LOG_SERVER_PORT || 8888;
    this.pythonServerHost = process.env.PYTHON_LOG_SERVER_HOST || 'localhost';
  }

  async initialize() {
    // Logger Ï¥àÍ∏∞Ìôî
    this.logger = createLogger({
      level: config.logging.level,
      enableFile: true,
      logDir: './logs'
    });

    // Î°úÍ∑∏ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî (AI Î∂ÑÏÑù Î™®ÎìàÎ≥¥Îã§ Î®ºÏ†Ä)
    await this.setupLogSystem();

    // AI Î∂ÑÏÑù Î™®Îìà Ï¥àÍ∏∞Ìôî
    await this.setupAIAnalysis();

    // Express ÎØ∏Îì§Ïõ®Ïñ¥ ÏÑ§Ï†ï
    this.setupExpressMiddleware();
    
    // ÎùºÏö∞Ìä∏ ÏÑ§Ï†ï
    this.setupRoutes();
    
    // WebSocket ÏÑúÎ≤Ñ Ï¥àÍ∏∞Ìôî
    this.setupWebSocketServer();
    
    // Graceful shutdown Ìï∏Îì§Îü¨
    this.setupGracefulShutdown();
  }

  async setupLogSystem() {
    console.log('üîç Setting up integrated log system...');
    
    try {
      // Python Î°úÍ∑∏ ÏÑúÎ≤Ñ ÏãúÏûë
      await this.startPythonLogServer();
      
      // Python ÏÑúÎ≤ÑÍ∞Ä ÏãúÏûëÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      if (this.pythonLogServer || await this.testPythonServerHealth()) {
        console.log('‚úÖ Python log server is running');
        
        // Í∞ÑÎã®Ìïú Î°úÍ∑∏ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îßå Ï¥àÍ∏∞Ìôî (Î≥µÏû°Ìïú Î∏åÎ¶¨ÏßÄ ÏóÜÏù¥)
        const JSONRPCClient = require('../shared/src/utils/JSONRPCClient');
        this.logClient = new JSONRPCClient(`http://localhost:${this.pythonServerPort}/rpc`);
        
        console.log('‚úÖ Log system client initialized');
        
        // Í∏∞Ï°¥ Î°úÍ±∞Î•º Î°úÍ∑∏ ÏãúÏä§ÌÖúÏúºÎ°ú Ïó∞Í≤∞
        this.connectLoggerToLogSystem();
        
        console.log('‚úÖ Log system integration completed');
      } else {
        console.warn('‚ö†Ô∏è Python log server not available, skipping log system integration');
      }
      
    } catch (error) {
      console.error('‚ùå Failed to setup log system:', error);
      // Î°úÍ∑∏ ÏãúÏä§ÌÖú Ïã§Ìå®Ìï¥ÎèÑ Î©îÏù∏ ÏÑúÎ≤ÑÎäî Í≥ÑÏÜç Ïã§Ìñâ
      this.logSystem = null;
      this.logCollectors = null;
    }
  }

  async startPythonLogServer() {
    console.log('üêç Starting Python log server...');
    
    try {
      // Ìè¨Ìä∏Í∞Ä Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ëÏù∏ÏßÄ ÌôïÏù∏
      const isPortInUse = await this.checkPortInUse(this.pythonServerPort);
      if (isPortInUse) {
        console.log(`üìù Python log server already running on port ${this.pythonServerPort}`);
        // Í∏∞Ï°¥ ÏÑúÎ≤ÑÍ∞Ä Ï†ïÏÉÅ ÏûëÎèôÌïòÎäîÏßÄ ÌôïÏù∏
        const isHealthy = await this.testPythonServerHealth();
        if (isHealthy) {
          console.log('‚úÖ Existing Python log server is healthy');
          return;
        } else {
          console.log('‚ö†Ô∏è Existing server is not responding, attempting to restart...');
          // Í∏∞Ï°¥ ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£å ÏãúÎèÑ
          await this.killProcessOnPort(this.pythonServerPort);
          await new Promise(resolve => setTimeout(resolve, 2000)); // 2Ï¥à ÎåÄÍ∏∞
        }
      }
      
      // Python ÏÑúÎ≤Ñ Ïã§Ìñâ Í≤ΩÎ°ú ÌôïÏù∏ (main.py ÏÇ¨Ïö©)
      const pythonServerPath = path.join(__dirname, '../../modules/log-system/python/main.py');
      if (!fs.existsSync(pythonServerPath)) {
        throw new Error(`Python server not found at: ${pythonServerPath}`);
      }
      
      // Python ÏÑúÎ≤Ñ Ïã§Ìñâ
      this.pythonLogServer = spawn('python', [
        pythonServerPath,
        '--host', this.pythonServerHost,
        '--port', this.pythonServerPort.toString(),
        '--db', './logs/recursive_logs.db'
      ], {
        stdio: ['ignore', 'pipe', 'pipe'],
        cwd: path.join(__dirname, '../../modules/log-system'),
        env: { ...process.env, PYTHONUNBUFFERED: '1' }
      });
      
      // ÏÑúÎ≤Ñ Ï∂úÎ†• Î°úÍπÖ
      this.pythonLogServer.stdout.on('data', (data) => {
        const output = data.toString().trim();
        if (output) {
          console.log(`üêç [PYTHON] ${output}`);
        }
      });
      
      this.pythonLogServer.stderr.on('data', (data) => {
        const error = data.toString().trim();
        if (error) {
          console.error(`üêç [PYTHON ERROR] ${error}`);
        }
      });
      
      this.pythonLogServer.on('error', (error) => {
        console.error('‚ùå Failed to start Python log server:', error);
        this.pythonLogServer = null;
      });
      
      this.pythonLogServer.on('exit', (code, signal) => {
        if (code !== 0 && !this.isShuttingDown) {
          console.error(`üêç Python log server exited with code ${code}, signal ${signal}`);
        } else {
          console.log('üêç Python log server stopped gracefully');
        }
        this.pythonLogServer = null;
      });
      
      // ÏÑúÎ≤Ñ ÏãúÏûë ÎåÄÍ∏∞
      await this.waitForPythonServer();
      console.log(`‚úÖ Python log server started on ${this.pythonServerHost}:${this.pythonServerPort}`);
      
    } catch (error) {
      console.error('‚ùå Failed to start Python log server:', error);
      // Python ÏÑúÎ≤Ñ Ïã§Ìå®Ìï¥ÎèÑ Î©îÏù∏ ÏÑúÎ≤ÑÎäî Í≥ÑÏÜç Ïã§Ìñâ
      this.pythonLogServer = null;
    }
  }
  
  async checkPortInUse(port) {
    return new Promise((resolve) => {
      const server = net.createServer();
      
      server.listen(port, (err) => {
        if (err) {
          resolve(true); // Ìè¨Ìä∏Í∞Ä ÏÇ¨Ïö© Ï§ë
        } else {
          server.once('close', () => {
            resolve(false); // Ìè¨Ìä∏Í∞Ä ÏÇ¨Ïö© Í∞ÄÎä•
          });
          server.close();
        }
      });
      
      server.on('error', () => {
        resolve(true); // Ìè¨Ìä∏Í∞Ä ÏÇ¨Ïö© Ï§ë
      });
    });
  }
  
  async waitForPythonServer(maxAttempts = 30, delay = 1000) {
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const response = await this.testPythonServerHealth();
        if (response) {
          return true;
        }
      } catch (error) {
        // Ïó∞Í≤∞ Ïã§Ìå®, Ïû¨ÏãúÎèÑ
      }
      
      if (attempt < maxAttempts) {
        console.log(`üêç Waiting for Python server... (${attempt}/${maxAttempts})`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    throw new Error('Python log server failed to start within timeout');
  }
  
  async testPythonServerHealth() {
    return new Promise((resolve) => {
      const req = http.request({
        hostname: this.pythonServerHost,
        port: this.pythonServerPort,
        path: '/health',
        method: 'GET',
        timeout: 2000
      }, (res) => {
        resolve(res.statusCode === 200);
      });
      
      req.on('error', () => resolve(false));
      req.on('timeout', () => {
        req.destroy();
        resolve(false);
      });
      
      req.end();
    });
  }

  async killProcessOnPort(port) {
    try {
      if (process.platform === 'win32') {
        // WindowsÏóêÏÑú Ìè¨Ìä∏Î•º ÏÇ¨Ïö©ÌïòÎäî ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£å
        const { exec } = require('child_process');
        return new Promise((resolve) => {
          exec(`netstat -ano | findstr :${port}`, (error, stdout) => {
            if (stdout) {
              const lines = stdout.split('\n').filter(line => line.includes(`LISTENING`));
              lines.forEach(line => {
                const pid = line.trim().split(/\s+/).pop();
                if (pid && pid !== '0') {
                  exec(`taskkill /F /PID ${pid}`, () => {
                    console.log(`üî™ Killed process ${pid} using port ${port}`);
                  });
                }
              });
            }
            resolve();
          });
        });
      } else {
        // Unix/LinuxÏóêÏÑú Ìè¨Ìä∏Î•º ÏÇ¨Ïö©ÌïòÎäî ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£å
        const { exec } = require('child_process');
        return new Promise((resolve) => {
          exec(`lsof -ti:${port}`, (error, stdout) => {
            if (stdout) {
              const pids = stdout.trim().split('\n');
              pids.forEach(pid => {
                if (pid) {
                  exec(`kill -9 ${pid}`, () => {
                    console.log(`üî™ Killed process ${pid} using port ${port}`);
                  });
                }
              });
            }
            resolve();
          });
        });
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to kill process on port ${port}:`, error.message);
    }
  }

  connectLoggerToLogSystem() {
    if (!this.logger) return;
    
    // Ìé∏Ïùò Î©îÏÑúÎìúÎì§ Ïó∞Í≤∞
    ['info', 'warn', 'error', 'debug'].forEach(level => {
      if (this.logger[level]) {
        const originalMethod = this.logger[level].bind(this.logger);
        this.logger[level] = (message, metadata = {}) => {
          // Í∏∞Ï°¥ Î°úÍπÖ ÏàòÌñâ
          originalMethod(message, metadata);
          
          // Python ÏÑúÎ≤ÑÎ°ú Î°úÍ∑∏ Ï†ÑÏÜ° (ÎπÑÎèôÍ∏∞, ÏóêÎü¨ Î¨¥Ïãú)
          if (this.logClient) {
            this.sendLogToPythonServer({
              source: 'recursive_server',
              level: level.toUpperCase(),
              message: typeof message === 'string' ? message : JSON.stringify(message),
              metadata: {
                component: 'server',
                ...metadata
              },
              tags: ['server', 'main']
            });
          }
        };
      }
    });
  }

  async sendLogToPythonServer(logEntry) {
    try {
      const response = await this.logClient.call('log', {
        ...logEntry,
        timestamp: new Date().toISOString()
      });
      // ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÑÏÜ°Îê®
    } catch (error) {
      // Î°úÍ∑∏ Ï†ÑÏÜ° Ïã§Ìå®Ìï¥ÎèÑ Î©îÏù∏ ÏÑúÎ≤ÑÏóêÎäî ÏòÅÌñ• ÏóÜÏùå
    }
  }

  async setupAIAnalysis() {
    try {
      this.aiAnalysis = getAIAnalysis({
        enablePythonUtils: true,
        logLevel: config.logging.level
      });
      
      await this.aiAnalysis.initialize();
      
      // Ïù¥Î≤§Ìä∏ Î≤ÑÏä§Ïóê Îì±Î°ù
      eventBus.registerModule('ai-analysis', this.aiAnalysis);
      
      this.logger.info('‚úÖ AI Analysis module initialized and registered');
    } catch (error) {
      this.logger.error('‚ùå Failed to initialize AI Analysis module:', error);
      // AI Î∂ÑÏÑù ÏóÜÏù¥ÎèÑ ÏÑúÎ≤ÑÍ∞Ä ÎèôÏûëÌï† Ïàò ÏûàÎèÑÎ°ù Ìï®
      this.aiAnalysis = null;
    }
  }

  setupExpressMiddleware() {
    // HTTP Î°úÍ∑∏ ÏàòÏßëÍ∏∞ ÎØ∏Îì§Ïõ®Ïñ¥ Ï∂îÍ∞Ä (Í∞ÄÏû• Î®ºÏ†Ä)
    if (this.logCollectors && this.logCollectors.collectors.has('recursive_http')) {
      const httpCollector = this.logCollectors.collectors.get('recursive_http');
      const httpMiddleware = httpCollector.createMiddleware();
      this.app.use(httpMiddleware);
      console.log('‚úÖ HTTP logging middleware registered');
    }

    // Î≥¥Ïïà Ìó§Îçî
    this.app.use(helmet({
      frameguard: { action: 'sameorigin' }, // X-Frame-OptionsÎ•º HTTP Ìó§ÎçîÎ°ú ÏÑ§Ï†ï
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'", "https://cdn.jsdelivr.net"],
          scriptSrcAttr: ["'unsafe-inline'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          connectSrc: ["'self'", "ws:", "wss:"],
          imgSrc: ["'self'", "data:", "blob:"],
          fontSrc: ["'self'", "data:"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"]
        }
      }
    }));

    // CORS ÏÑ§Ï†ï
    this.app.use(cors({
      origin: config.websocket.security.allowedOrigins,
      credentials: true
    }));

    // ÏïïÏ∂ï
    this.app.use(compression());

    // Rate limiting
    const limiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15Î∂Ñ
      max: 100, // ÏöîÏ≤≠ Ï†úÌïú
      message: 'Too many requests from this IP'
    });
    this.app.use('/api/', limiter);

    // JSON ÌååÏã±
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true }));

    // Ï†ïÏ†Å ÌååÏùº ÏÑúÎπô - Public Directory
    this.app.use(express.static(path.join(__dirname, 'public')));
    
    // User Interface ÎπåÎìú Í≤∞Í≥ºÎ¨º ÏÑúÎπô (assets, fonts, icons Îì±)
    this.app.use('/assets', express.static(path.join(__dirname, '../../modules/user-interface/build/assets')));
    this.app.use('/fonts', express.static(path.join(__dirname, '../../modules/user-interface/build/fonts')));
    this.app.use('/icons', express.static(path.join(__dirname, '../../modules/user-interface/build/icons')));
    this.app.use('/images', express.static(path.join(__dirname, '../../modules/user-interface/build/images')));
    
    // favicon ÏßÅÏ†ë ÏÑúÎπô
    this.app.get('/favicon.ico', (req, res) => {
      res.sendFile(path.join(__dirname, '../../modules/user-interface/build/favicon.ico'));
    });
    
    // Î©îÏù∏ UI ÎùºÏö∞ÌåÖ (SPA ÏßÄÏõê)
    this.app.get('/ui', (req, res) => {
      res.sendFile(path.join(__dirname, '../../modules/user-interface/build/index.html'));
    });
    
    // SPA ÎùºÏö∞ÌåÖ ÏßÄÏõê (Î™®Îì† UI Í≤ΩÎ°úÎ•º index.htmlÎ°ú Î¶¨Îã§Ïù¥Î†âÌä∏)
    this.app.get('/ui/*', (req, res) => {
      res.sendFile(path.join(__dirname, '../../modules/user-interface/build/index.html'));
    });
  }

  setupRoutes() {
    // Ìó¨Ïä§ Ï≤¥ÌÅ¨
    this.app.get('/health', (req, res) => {
      const metrics = this.wsServer ? this.wsServer.getMetrics() : null;
      const logSystemStatus = this.logSystem ? this.logSystem.getSystemStatus() : null;
      const collectorsStatus = this.logCollectors ? this.logCollectors.getStatus() : null;
      
      res.json({
        status: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        websocket: metrics,
        logSystem: {
          enabled: !!this.logSystem,
          status: logSystemStatus,
          collectors: collectorsStatus
        }
      });
    });

    // API Ìó¨Ïä§ Ï≤¥ÌÅ¨ (ÌîÑÎ°†Ìä∏ÏóîÎìúÏóêÏÑú Í∏∞ÎåÄÌïòÎäî ÏóîÎìúÌè¨Ïù∏Ìä∏)
    this.app.get('/api/health', (req, res) => {
      res.json({
        status: 'healthy',
        service: 'api',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage()
      });
    });

    // Î©îÌä∏Î¶≠ API Ìó¨Ïä§ Ï≤¥ÌÅ¨
    this.app.get('/api/metrics/health', (req, res) => {
      res.json({
        status: 'healthy',
        service: 'metrics',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
      });
    });

    // WebSocket Î©îÌä∏Î¶≠
    this.app.get('/api/metrics', (req, res) => {
      if (!this.wsServer) {
        return res.status(503).json({ error: 'WebSocket server not initialized' });
      }

      const metrics = this.wsServer.getMetrics();

      res.json({
        websocket: metrics,
        server: {
          uptime: process.uptime(),
          memory: process.memoryUsage(),
          timestamp: new Date().toISOString()
        }
      });
    });

    // Ïã§ÏãúÍ∞Ñ Î©îÌä∏Î¶≠ Îç∞Ïù¥ÌÑ∞ (ÌîÑÎ°†Ìä∏ÏóîÎìúÏóêÏÑú Í∏∞ÎåÄÌïòÎäî ÌòïÏãù)
    this.app.get('/api/metrics/data', (req, res) => {
      const metrics = this.wsServer ? this.wsServer.getMetrics() : {};
      const memoryUsage = process.memoryUsage();
      
      res.json({
        timestamp: new Date().toISOString(),
        connections: {
          active: metrics.connections?.active || 0,
          total: metrics.connections?.total || 0
        },
        messages: {
          sent: metrics.messages?.sent || 0,
          received: metrics.messages?.received || 0,
          errors: metrics.messages?.errors || 0
        },
        performance: {
          uptime: process.uptime(),
          cpu: process.cpuUsage(),
          memory: {
            used: memoryUsage.heapUsed,
            total: memoryUsage.heapTotal,
            external: memoryUsage.external,
            rss: memoryUsage.rss
          }
        },
        system: {
          nodeVersion: process.version,
          platform: process.platform,
          arch: process.arch
        }
      });
    });

    // API ÏÑúÎ≤Ñ Í∏∞Îä•Îì§
    this.app.get('/api/status', (req, res) => {
      res.json({
        api: 'running',
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        services: {
          websocket: !!this.wsServer,
          mcp: !!this.mcpServer,
          logSystem: !!this.logSystem,
          aiAnalysis: !!this.aiAnalysis
        }
      });
    });

    // ÏãúÏä§ÌÖú Ï†ïÎ≥¥ API
    this.app.get('/api/system/info', (req, res) => {
      res.json({
        node: {
          version: process.version,
          platform: process.platform,
          arch: process.arch,
          uptime: process.uptime()
        },
        memory: process.memoryUsage(),
        env: process.env.NODE_ENV || 'development',
        timestamp: new Date().toISOString()
      });
    });

    // Ïó∞Í≤∞ Ï†ïÎ≥¥ API
    this.app.get('/api/connections', (req, res) => {
      if (!this.wsServer) {
        return res.status(503).json({ error: 'WebSocket server not available' });
      }

      const connections = this.wsServer.connectionHandler.getAllConnections();
      const connectionInfo = Object.entries(connections).map(([id, conn]) => ({
        id,
        connected: conn.readyState === 1,
        connectTime: conn.connectTime || new Date().toISOString(),
        lastActivity: conn.lastActivity || new Date().toISOString()
      }));

      res.json({
        total: connectionInfo.length,
        active: connectionInfo.filter(c => c.connected).length,
        connections: connectionInfo
      });
    });

    // Î©îÏãúÏßÄ Ï†ÑÏÜ° API
    this.app.post('/api/broadcast', (req, res) => {
      if (!this.wsServer) {
        return res.status(503).json({ error: 'WebSocket server not available' });
      }

      const { message, type = 'broadcast' } = req.body;
      
      if (!message) {
        return res.status(400).json({ error: 'Message is required' });
      }

      const broadcastData = {
        type,
        data: message,
        from: 'api',
        timestamp: new Date().toISOString()
      };

      const sentCount = this.wsServer.broadcast(broadcastData);
      
      res.json({
        success: true,
        sentTo: sentCount,
        message: broadcastData,
        timestamp: new Date().toISOString()
      });
    });
  
    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÎùºÏù¥Î∏åÎü¨Î¶¨ Îã§Ïö¥Î°úÎìú
    this.app.get('/api/client-library', (req, res) => {
      res.sendFile(path.join(__dirname, 'public/js/websocket-client.js'));
    });

    // Î°úÍ∑∏ ÏãúÏä§ÌÖú API ÎùºÏö∞Ìä∏Îì§
    this.app.get('/api/logs/status', (req, res) => {
      if (!this.logSystem) {
        return res.status(503).json({ error: 'Log system not available' });
      }
      
      const status = this.logSystem.getSystemStatus();
      const collectorsStatus = this.logCollectors ? this.logCollectors.getStatus() : null;
      
      res.json({
        logSystem: status,
        collectors: collectorsStatus,
        timestamp: new Date().toISOString()
      });
    });

    this.app.get('/api/logs/stats', async (req, res) => {
      if (!this.logSystem) {
        return res.status(503).json({ error: 'Log system not available' });
      }
      
      try {
        const timerange = req.query.timerange || '1h';
        const stats = await this.logSystem.getStats(timerange);
        res.json(stats);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    this.app.post('/api/logs/search', async (req, res) => {
      if (!this.logSystem) {
        return res.status(503).json({ error: 'Log system not available' });
      }
      
      try {
        const { query, timerange = '1h', context = 3 } = req.body;
        if (!query) {
          return res.status(400).json({ error: 'Query parameter required' });
        }
        
        const results = await this.logSystem.search(query, timerange, context);
        res.json(results);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // üé® Phase 5.1: UI Module Integration - V2 ONLY MODE
    console.log('üé® Setting up User Interface V2 (V1 temporarily disabled)...');
    
    // üé® User Interface V2 - Î©îÏù∏ ÎèÑÎ©îÏù∏ÏóêÏÑú ÏßÅÏ†ë ÏÑúÎπô
    console.log('üéØ V2 UI now serving on main domain (localhost:3001)');
    
    // V2 Ï†ïÏ†Å ÌååÏùº ÏÑúÎπô (Î©îÏù∏ ÎèÑÎ©îÏù∏ÏóêÏÑú)
    this.app.use('/', express.static(
      path.join(__dirname, '../../modules/user-interface-v2/dist'),
      { 
        index: false,  // ÏûêÎèô Ïù∏Îç±Ïä§ ÌååÏùº ÏÑúÎπô ÎπÑÌôúÏÑ±Ìôî
        fallthrough: true  // ÌååÏùºÏù¥ ÏóÜÏúºÎ©¥ Îã§Ïùå ÎØ∏Îì§Ïõ®Ïñ¥Î°ú ÎÑòÏñ¥Í∞ê
      }
    ));
    
    // Î©îÏù∏ ÌéòÏù¥ÏßÄÏôÄ Î™®Îì† SPA ÎùºÏö∞Ìä∏Î•º V2 index.htmlÎ°ú ÏÑúÎπô
    this.app.get('/', (req, res) => {
      console.log(`üéØ V2 Main Route: ${req.url}`);
      res.sendFile(path.join(__dirname, '../../modules/user-interface-v2/dist/index.html'));
    });
    
    // SPA ÎùºÏö∞ÌåÖ ÏßÄÏõê (Ìï¥Ïãú ÎùºÏö∞ÌåÖÏù¥ÎØÄÎ°ú Î©îÏù∏ ÌéòÏù¥ÏßÄÏóêÏÑú Ï≤òÎ¶¨)
    this.app.get('*', (req, res) => {
      // API Í≤ΩÎ°úÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå V2 UI ÏÑúÎπô
      if (!req.path.startsWith('/api/')) {
        console.log(`üéØ V2 SPA Route: ${req.url}`);
        res.sendFile(path.join(__dirname, '../../modules/user-interface-v2/dist/index.html'));
      }
    });
    
    // V1 UI ÏûÑÏãú ÎπÑÌôúÏÑ±Ìôî (Ï†ëÍ∑º Ïãú V2Î°ú Î¶¨Îã§Ïù¥Î†âÌä∏)
    // this.app.use('/ui', express.static(
    //   path.join(__dirname, '../../modules/user-interface/build')
    // ));
    this.app.get('/ui', (req, res) => {
      console.log('üîÑ V1 UI access redirected to V2');
      res.redirect('/');
    });
    
    this.app.get('/v2', (req, res) => {
      console.log('üîÑ /v2 access redirected to main domain');
      res.redirect('/');
    });
    
    // API ÎùºÏö∞Ìä∏Îì§
    this.app.use('/api/v2', (req, res, next) => {
      res.json({
        message: 'UI V2 API endpoint ready',
        version: '2.0.0',
        features: ['simplified-ui', 'log-dashboard', 'ai-planner'],
        timestamp: new Date().toISOString()
      });
    });
    
    // Î†àÍ±∞Ïãú UI Ï†ëÍ∑º (Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
    this.app.get('/legacy', (req, res) => {
      res.sendFile(path.join(__dirname, 'public/index.html'));
    });
    
    console.log('‚úÖ Modular UI system ready');

    // 404 Ìï∏Îì§Îü¨
    this.app.use((req, res) => {
      res.status(404).json({ error: 'Not found' });
    });

    // ÏóêÎü¨ Ìï∏Îì§Îü¨
    this.app.use((error, req, res, next) => {
      this.logger.error('Express error:', { 
        error: error.message, 
        stack: error.stack,
        url: req.url,
        method: req.method
      });
      
      res.status(500).json({ 
        error: 'Internal server error',
        timestamp: new Date().toISOString()
      });
    });
  }

  setupWebSocketServer() {
    // WebSocket ÏÑúÎ≤Ñ Ï¥àÍ∏∞Ìôî (Ïû¨Ïó∞Í≤∞ Ìï∏Îì§Îü¨Îäî Ïù¥Ï†ú Î™®ÎìàÏóê ÎÇ¥Ïû•Îê®)
    // Ï£ºÏùò: HTTP ÏÑúÎ≤ÑÍ∞Ä ÏãúÏûëÎêú ÌõÑÏóê WebSocket ÏÑúÎ≤ÑÎ•º ÏãúÏûëÌï¥Ïïº Ìï®
    this.wsServer = new WebSocketProtocolServer(this.server, config);
    
    // WebSocket ÏÑúÎ≤Ñ ÏãúÏûë
    this.wsServer.start();

    // MCP ÏÑúÎ≤Ñ Ï¥àÍ∏∞Ìôî (LLM ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ÑÎã¨)
    let llmClient = null;
    try {
      const { clients: { LLMClient } } = require('@recursive/shared');
      llmClient = new LLMClient();
      this.logger.info('‚úÖ LLM Client initialized successfully');
    } catch (error) {
      this.logger.warn('‚ö†Ô∏è LLM Client not available:', error.message);
      // LLM ClientÍ∞Ä ÏóÜÏñ¥ÎèÑ ÏÑúÎ≤ÑÎäî Í≥ÑÏÜç Ïã§Ìñâ
    }
    
    this.mcpServer = new MCPServer(this.wsServer, llmClient);
    this.logger.info('MCP Server initialized');

    // WebSocket Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
    this.wsServer.on('connectionAdded', (connectionId, connectionInfo) => {
      this.logger.logConnection(connectionId, connectionInfo.clientIp, connectionInfo.userAgent);
      
      // ÏÑ∏ÏÖò Ï†ïÎ≥¥ ÏÉùÏÑ± (Ïû¨Ïó∞Í≤∞ Ìï∏Îì§Îü¨Îäî Ïù¥Ï†ú Î™®ÎìàÏóê ÎÇ¥Ïû•Îê®)
      const sessionId = require('crypto').randomUUID();
      
      // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å ÏÑ∏ÏÖò Ï†ïÎ≥¥ Ï†ÑÏÜ°
      this.wsServer.sendToConnection(connectionId, {
        type: 'session_created',
        sessionId: sessionId,
        isReconnection: false, // Î™®ÎìàÏóêÏÑú Ï≤òÎ¶¨Îê®
        timestamp: new Date().toISOString()
      });
    });

    this.wsServer.on('connectionRemoved', (connectionId, connectionInfo) => {
      this.logger.logDisconnection(connectionId, 'unknown', 'Connection removed');
      // Ïû¨Ïó∞Í≤∞ Ìï∏Îì§Îü¨Îäî Ïù¥Ï†ú Î™®ÎìàÏóêÏÑú ÏûêÎèôÏúºÎ°ú Ï≤òÎ¶¨Îê®
    });

    this.wsServer.on('message', ({ connectionId, message, connectionInfo }) => {
      this.logger.logMessage(connectionId, message.type, JSON.stringify(message).length);
      
      // Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î†àÎ≤® Î©îÏãúÏßÄ Ï≤òÎ¶¨
      this.handleApplicationMessage(connectionId, message, connectionInfo);
    });

    this.wsServer.on('userAuthenticated', (connectionId, userId) => {
      this.logger.info('User authenticated', { connectionId, userId });
    });

    this.wsServer.on('metrics', (metrics) => {
      this.logger.logMetrics(metrics);
    });

    this.wsServer.on('error', (error) => {
      this.logger.error('WebSocket server error:', error);
    });
  }

  handleApplicationMessage(connectionId, message, connectionInfo) {
    try {
      switch (message.type) {
        case 'chat':
          this.handleChatMessage(connectionId, message);
          break;
          
        case 'broadcast':
          this.handleBroadcastMessage(connectionId, message);
          break;
          
        case 'echo':
          this.handleEchoMessage(connectionId, message);
          break;
          
        case 'complexity_analysis':
          this.handleComplexityAnalysis(connectionId, message);
          break;
          
        case 'mcp_request':
        case 'mcp_notification':
          // MCP Î©îÏãúÏßÄÎ•º MCP ÏÑúÎ≤ÑÎ°ú Ï†ÑÎã¨
          this.handleMCPMessage(connectionId, message);
          break;
          
        default:
          this.logger.warn('Unknown message type:', { 
            connectionId, 
            type: message.type 
          });
      }
    } catch (error) {
      this.logger.logError(connectionId, error, { message });
      
      this.wsServer.sendToConnection(connectionId, {
        type: 'error',
        message: 'Failed to process message',
        timestamp: new Date().toISOString()
      });
    }
  }

  handleMCPMessage(connectionId, message) {
    // console.log('Server handleMCPMessage called with:', {
    //   connectionId,
    //   messageType: typeof message,
    //   messageData: message
    // });
    
    // WebSocket Í∞ùÏ≤¥Î•º Ï∞æÏïÑÏÑú MCP ÏÑúÎ≤ÑÎ°ú Ï†ÑÎã¨
    const ws = this.wsServer.connectionHandler.getConnection(connectionId);
    if (ws && this.mcpServer) {
      // MCP ÏùëÎãµÏùÑ ÏúÑÌï¥ connectionIdÎ•º WebSocket Í∞ùÏ≤¥Ïóê Ï†ÄÏû•
      ws.connectionId = connectionId;
      ws.serverInstance = this;
      this.mcpServer.handleMCPMessage(ws, message);
    } else {
      this.logger.error('Cannot handle MCP message: WebSocket or MCP server not available', {
        connectionId,
        hasWs: !!ws,
        hasMcpServer: !!this.mcpServer
      });
    }
  }

  handleChatMessage(connectionId, message) {
    const response = {
      type: 'chat_response',
      data: {
        originalMessage: message.data,
        response: `Echo: ${message.data}`,
        timestamp: new Date().toISOString(),
        connectionId
      }
    };

    this.wsServer.sendToConnection(connectionId, response);
  }

  handleBroadcastMessage(connectionId, message) {
    const broadcastData = {
      type: 'broadcast',
      data: message.data,
      from: connectionId,
      timestamp: new Date().toISOString()
    };

    const sentCount = this.wsServer.broadcast(broadcastData, [connectionId]);
    
    this.wsServer.sendToConnection(connectionId, {
      type: 'broadcast_status',
      sentTo: sentCount,
      timestamp: new Date().toISOString()
    });
  }

  handleEchoMessage(connectionId, message) {
    this.wsServer.sendToConnection(connectionId, {
      type: 'echo_response',
      data: message.data,
      timestamp: new Date().toISOString()
    });
  }

  async handleComplexityAnalysis(connectionId, message) {
    try {
      // Î∂ÑÏÑù ÏãúÏûë ÏïåÎ¶º
      this.wsServer.sendToConnection(connectionId, {
        type: 'complexity_analysis_started',
        data: {
          message: 'AI Î≥µÏû°ÎèÑ Î∂ÑÏÑùÏùÑ ÏãúÏûëÌï©ÎãàÎã§...',
          timestamp: new Date().toISOString()
        }
      });

      let analysisResult;

      if (this.aiAnalysis) {
        // Ïã§Ï†ú AI Î∂ÑÏÑù Î™®Îìà ÏÇ¨Ïö©
        this.logger.info('Starting AI complexity analysis', { connectionId, input: message.data });
        
        analysisResult = await this.aiAnalysis.analyzeComplexity(message.data, {
          includeRecommendations: true,
          includeMetrics: true,
          analysisDepth: 'detailed'
        });

        this.logger.info('AI complexity analysis completed', { 
          connectionId, 
          complexity: analysisResult.complexity 
        });
      } else {
        // Ìè¥Î∞±: Í∏∞Î≥∏ Î∂ÑÏÑù
        this.logger.warn('AI analysis module not available, using fallback analysis');
        
        analysisResult = {
          complexity: 'medium',
          confidence: 0.7,
          recommendations: [
            'ÏΩîÎìú Î™®ÎìàÌôî Í∂åÏû•',
            'Îã®ÏúÑ ÌÖåÏä§Ìä∏ Ï∂îÍ∞Ä ÌïÑÏöî',
            'Î¨∏ÏÑúÌôî Í∞úÏÑ† Í∂åÏû•',
            'AI Î∂ÑÏÑù Î™®ÎìàÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ Í∏∞Î≥∏ Î∂ÑÏÑùÏùÑ ÏÇ¨Ïö©ÌñàÏäµÎãàÎã§.'
          ],
          metrics: {
            linesOfCode: Math.floor(Math.random() * 1000) + 100,
            cyclomaticComplexity: Math.floor(Math.random() * 20) + 1,
            maintainabilityIndex: Math.floor(Math.random() * 100),
            estimatedDevelopmentTime: '2-4 ÏãúÍ∞Ñ'
          },
          analysis: {
            method: 'fallback',
            aiAvailable: false,
            timestamp: new Date().toISOString()
          }
        };
      }

      // Í≤∞Í≥º Ï†ÑÏÜ°
      const response = {
        type: 'complexity_result',
        data: {
          ...analysisResult,
          inputData: message.data,
          processingTime: Date.now() - Date.parse(new Date().toISOString()),
          timestamp: new Date().toISOString()
        }
      };

      this.wsServer.sendToConnection(connectionId, response);

      // Ïù¥Î≤§Ìä∏ Î≤ÑÏä§Î°ú Î∂ÑÏÑù ÏôÑÎ£å ÏïåÎ¶º
      eventBus.emit('complexity:analysis:completed', {
        connectionId,
        result: analysisResult,
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      this.logger.error('Complexity analysis failed:', { 
        connectionId, 
        error: error.message,
        stack: error.stack 
      });

      // ÏóêÎü¨ ÏùëÎãµ
      this.wsServer.sendToConnection(connectionId, {
        type: 'complexity_error',
        data: {
          error: 'AI Î≥µÏû°ÎèÑ Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.',
          details: error.message,
          timestamp: new Date().toISOString()
        }
      });
    }
  }

  setupGracefulShutdown() {
    const shutdown = async (signal) => {
      if (this.isShuttingDown) return;
      
      this.isShuttingDown = true;
      this.logger.info(`Received ${signal}, starting graceful shutdown...`);

      try {
        // WebSocket ÏÑúÎ≤Ñ Ï¢ÖÎ£å
        if (this.wsServer) {
          await this.wsServer.stop();
        }

        // Python Î°úÍ∑∏ ÏÑúÎ≤Ñ Ï¢ÖÎ£å
        if (this.pythonLogServer) {
          this.logger.info('Stopping Python log server...');
          this.pythonLogServer.kill('SIGTERM');
          
          // Í∞ïÏ†ú Ï¢ÖÎ£å ÎåÄÍ∏∞
          await new Promise((resolve) => {
            const timeout = setTimeout(() => {
              if (this.pythonLogServer) {
                this.pythonLogServer.kill('SIGKILL');
                this.logger.warn('Python log server force killed');
              }
              resolve();
            }, 5000);
            
            if (this.pythonLogServer) {
              this.pythonLogServer.on('exit', () => {
                clearTimeout(timeout);
                resolve();
              });
            } else {
              clearTimeout(timeout);
              resolve();
            }
          });
          
          this.logger.info('Python log server stopped');
        }

        // Î°úÍ∑∏ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ïÎ¶¨
        if (this.logClient) {
          this.logClient = null;
          this.logger.info('Log client disconnected');
        }

        // HTTP ÏÑúÎ≤Ñ Ï¢ÖÎ£å
        this.server.close(() => {
          this.logger.info('HTTP server closed');
          
          // Logger Ï¢ÖÎ£å
          if (this.logger) {
            this.logger.close();
          }
          
          process.exit(0);
        });

        // Í∞ïÏ†ú Ï¢ÖÎ£å ÌÉÄÏù¥Î®∏
        setTimeout(() => {
          this.logger.error('Forced shutdown due to timeout');
          process.exit(1);
        }, 30000);

      } catch (error) {
        this.logger.error('Error during shutdown:', error);
        process.exit(1);
      }
    };

    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));
    
    process.on('uncaughtException', (error) => {
      console.error('üö® UNCAUGHT EXCEPTION:', error);
      console.error('Stack trace:', error.stack);
      this.logger.error('Uncaught exception:', { 
        message: error.message, 
        stack: error.stack,
        name: error.name 
      });
      
      // LLM Client Í¥ÄÎ†® Ïò§Î•òÎäî ÏÑúÎ≤ÑÎ•º Ï¢ÖÎ£åÌïòÏßÄ ÏïäÏùå
      if (error.message && error.message.includes('LLMClient')) {
        this.logger.warn('LLM Client related error, continuing operation...');
        return;
      }
      
      // Îã§Î•∏ Ïã¨Í∞ÅÌïú Ïò§Î•òÎßå ÏÑúÎ≤Ñ Ï¢ÖÎ£å
      shutdown('uncaughtException');
    });
    
    process.on('unhandledRejection', (reason, promise) => {
      console.error('Unhandled Rejection at:', promise, 'reason:', reason);
      this.logger.error('Unhandled rejection:', { reason, promise });
      
      // MCP Í¥ÄÎ†® Ïò§Î•òÎäî ÏÑúÎ≤ÑÎ•º Ï¢ÖÎ£åÌïòÏßÄ ÏïäÏùå
      if (reason && reason.message && reason.message.includes('MCP')) {
        this.logger.warn('MCP-related rejection, continuing operation...');
        return;
      }
      
      // Îã§Î•∏ Ïã¨Í∞ÅÌïú Ïò§Î•òÎßå ÏÑúÎ≤Ñ Ï¢ÖÎ£å
      this.logger.warn('Unhandled rejection detected, but continuing operation...');
      // shutdown('unhandledRejection');
    });
  }

  start() {
    const port = config.server.port;
    const host = config.server.host;

    this.server.listen(port, host, () => {
      this.logger.info(`üöÄ Recursive WebSocket Server started successfully`);
      this.logger.info(`üì° HTTP Server: http://${host}:${port}`);
      this.logger.info(`üîå WebSocket Server: ws://${host}:${port}`);
      this.logger.info(`üìä Health Check: http://${host}:${port}/health`);
      this.logger.info(`üìà Metrics: http://${host}:${port}/api/metrics`);
      
      if (this.pythonLogServer) {
        this.logger.info(`üêç Python Log Server: http://${this.pythonServerHost}:${this.pythonServerPort}`);
        this.logger.info(`üìù Log System API: http://${this.pythonServerHost}:${this.pythonServerPort}/rpc`);
      }
    });

    this.server.on('error', (error) => {
      this.logger.error('Server error:', error);
      process.exit(1);
    });
  }
}

// ÏÑúÎ≤Ñ ÏãúÏûë
if (require.main === module) {
  (async () => {
    try {
      const server = new RecursiveServer();
      await server.initialize(); // ÎπÑÎèôÍ∏∞ Ï¥àÍ∏∞Ìôî ÎåÄÍ∏∞
      server.start();
    } catch (error) {
      console.error('‚ùå Failed to start server:', error);
      process.exit(1);
    }
  })();
}

module.exports = RecursiveServer; 